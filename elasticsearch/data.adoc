es中，默认情况下所有的数据的每个field都会被索引。

## Document Metadata

_index: where the document lives。一般，将同种类型的数据放在一个index中。尽管可以将不相关的数据
放在一个index中，但通常这是一种反模式。索引名称必须是小写字母，不能以下划线开头，不能包含逗号。

_type: index是更宽松的分组，_type是index下更具体的划分。_type的名称可以大小写，但不能以下划线或.开头，
也不能包含逗号，最大长度是256字符。

_id: 是一个字符串，与_index和_type一起时，可以唯一确定es中的一个文档。当创建文档时，可以提供一个ID，
也可以让es自动为你生成(自动生成的ID是长度为20字节，URL-safe，且经过Base64-encode的GUID)。

## Retrieving a Document

部分获取：
```
curl -X GET "localhost:9200/website/blog/123?_source=title,text"
```
仅获取_source，不获取metadata：
```
curl -X GET "localhost:9200/website/blog/123/_source"
```

## 检查文档是否存在

```
curl -i -XHEAD http://localhost:9200/website/blog/123
```

NOTE: 检查时不存在不意味着1ms之后不存在。其他的进程可能正在创建文档。

## [[update_whole]]更新整个文档

```
curl -X PUT "localhost:9200/website/blog/123" -H 'Content-Type: application/json' -d'
{
  "title": "My first blog entry",
  "text":  "I am starting to get the hang of this...",
  "date":  "2014/01/02"
}
'
```

在集群内部，es将老的文档标记为deleted，并且添加一个完整的新文档。即使不能访问，老版本的文档
也不会立即删除。当你为更多的数据建立索引时，es会删掉标记为deleted的文档。

## [[create_document]]创建文档

指定id创建新文档（不更新文档）
```
PUT /website/blog/123?op_type=create
{ ... }
```
or
```
PUT /website/blog/123/_create
{ ... }
```
## [[delete_document]]删除文档

```
curl -X DELETE "localhost:9200/website/blog/123"
```

## 乐观并发控制

所有的更新或者删除文档的 API 可以接受参数if_seq_no和if_primary_term进行乐观并发控制。

NOTE: 使用外部系统的版本，请在创建、更新、删除的请求中添加请求参数version_type=external。

## [[update_partial]]部分更新文档

### 新增field

```
curl -X POST "localhost:9200/website/blog/1/_update" -H 'Content-Type: application/json' -d'
{
   "doc" : {
      "tags" : [ "testing" ],
      "views": 0
   }
}
'
```

### 使用Scripts做部分更新

```
// 自增 integer
curl -X POST "localhost:9200/website/blog/1/_update" -H 'Content-Type: application/json' -d'
{
   "script" : "ctx._source.views+=1"
}
'

// 增加 tag
curl -X POST "localhost:9200/website/blog/1/_update" -H 'Content-Type: application/json' -d'
{
  "script": {
    "lang": "painless",
    "inline": "ctx._source.tags.add(params.tags)",
    "params": {
      "tags": "search"
    }
  }
}
'

// 条件删除
curl -X POST "localhost:9200/website/blog/1/_update" -H 'Content-Type: application/json' -d'
{
   "script" : "ctx.op = ctx._source.views == count ? \u0027delete\u0027 : \u0027none\u0027",
    "params" : {
        "count": 1
    }
}
'

// 不存在则插入
curl -X POST "localhost:9200/website/blog/1/_update" -H 'Content-Type: application/json' -d'
{
   "script" : "ctx.op = ctx._source.views == count ? \u0027delete\u0027 : \u0027none\u0027",
    "params" : {
        "count": 1
    }
}
'

// 冲突时重试（[red]#新版本的es去掉了type的概念#）
curl -X POST "localhost:9200/website/pageviews/1/_update?retry_on_conflict=5" -H 'Content-Type: application/json' -d'
{
   "script" : "ctx._source.views+=1",
   "upsert": {
       "views": 0
   }
}
'
```

### 获取多个文档

```
// 跨index获取多个文档
curl -X GET "localhost:9200/_mget" -H 'Content-Type: application/json' -d'
{
   "docs" : [
      {
         "_index" : "website",
         "_type" :  "blog",
         "_id" :    2
      },
      {
         "_index" : "website",
         "_type" :  "pageviews",
         "_id" :    1,
         "_source": "views"
      }
   ]
}
'

// 跨 type 获取多个文档，6版本之前
curl -X GET "localhost:9200/website/blog/_mget" -H 'Content-Type: application/json' -d'
{
   "docs" : [
      { "_id" : 2 },
      { "_type" : "pageviews", "_id" :   1 }
   ]
}
'

// 同一个index下，获取多个文档
curl -X GET "localhost:9200/website/blog/_mget?pretty" -H 'Content-Type: application/json' -d'
{
   "ids": ["2", "1"]
}
'
```
NOTE: 某个文档获取不到，不影响其他文档的获取。即使全部都没有获取到，http请求还是会返回200状态码。
每个文档的found字段表明了获取结果。

### Bulk API

Bulk API 允许在一步中做多个create、index、update 或则 delete 操作。

Bulk 请求的请求体格式如下：
```
{ action: { metadata }}\n
{ request body        }\n
{ action: { metadata }}\n
{ request body        }\n
...
```
两点需要注意：
* 每一行必须以\n结尾，包括最后一行。
* 每一行行中不能包含未经转义的换行符。

action/metadata行指定了对哪个文档做是什么操作。

action可以为：

1. create：仅当文档不存在时创建文档。参见<<create_document, 创建文档>>。

1. index：创建新文档或者替换已存在的文档。参见<<create_document, 创建文档>>和<<update_whole,更新整个文档>>。

1. update：部分更新文档。参见<<update_partial,部分更新>>。

1. delete：删除文档。参见<<delete_document, 删除文档>>。

Metadata指定了被操作文档的_index,_type和_id。例如，删除请求可能如下所示：

```
{ "delete": { "_index": "website", "_type": "blog", "_id": "123" }}
```

Request body 行由文档的_source组成。index 和 create 操作必须包含request body。Update 操作的request body 跟 update API：doc、upsert,script 相同。

一个包含上述操作的 bulk 请求示例如下：
```
curl -X POST "localhost:9200/_bulk" -H 'Content-Type: application/json' -d'
{ "delete": { "_index": "website", "_type": "blog", "_id": "123" }}
{ "create": { "_index": "website", "_type": "blog", "_id": "123" }}
{ "title":    "My first blog post" }
{ "index":  { "_index": "website", "_type": "blog" }}
{ "title":    "My second blog post" }
{ "update": { "_index": "website", "_type": "blog", "_id": "123", "_retry_on_conflict" : 3} }
{ "doc" : {"title" : "My updated blog post"} }
'
```

响应包含 items 数组，里面包含了每一次操作的操作结果，跟请求的顺序一样：

```
{
  "took": 279,
  "errors": false,
  "items": [
    {
      "delete": {
        "_index": "website",
        "_type": "blog",
        "_id": "123",
        "_version": 5,
        "result": "deleted",
        "_shards": {
          "total": 2,
          "successful": 2,
          "failed": 0
        },
        "_seq_no": 12,
        "_primary_term": 1,
        "status": 200
      }
    },
    {
      "create": {
        "_index": "website",
        "_type": "blog",
        "_id": "123",
        "_version": 6,
        "result": "created",
        "_shards": {
          "total": 2,
          "successful": 2,
          "failed": 0
        },
        "_seq_no": 13,
        "_primary_term": 1,
        "status": 201
      }
    },
    {
      "index": {
        "_index": "website",
        "_type": "blog",
        "_id": "uGof2GoB5qGHUDo2wakg",
        "_version": 1,
        "result": "created",
        "_shards": {
          "total": 2,
          "successful": 2,
          "failed": 0
        },
        "_seq_no": 14,
        "_primary_term": 1,
        "status": 201
      }
    },
    {
      "update": {
        "_index": "website",
        "_type": "blog",
        "_id": "123",
        "_version": 7,
        "result": "updated",
        "_shards": {
          "total": 2,
          "successful": 2,
          "failed": 0
        },
        "_seq_no": 15,
        "_primary_term": 1,
        "status": 200
      }
    }
  ]
}
```

NOTE: bulk API 不是原子性的，不能用来实现事务。

#### 请求体最大可以是多大

bulk 请求数据需要被加载到内存中，所以请求体越大，其他请求的可用内存越小。

最有的大小取决于硬件资源，文档的大小和复杂性，索引和查询负载。

当性能开始下降时，请求体就太大了。一般从bulk操作中包含1000~5000个文档或者请求体总大小为5~15M开始优化bulk请求。